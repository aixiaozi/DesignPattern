## 抽象工厂模式

**提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类，具体的工厂负责实现具体的产品实例**。  

## 主要角色

>主要对象
>**抽象工厂**：描述具体工厂的公共接口  
>**具体工厂**：描述具体工厂，创建产品的实例，供外界调用  
>**抽象产品族**：描述抽象产品的公共接口  
>**抽象产品**：描述具体产品的公共接口  
>**具体产品**：具体产品


## 针对工厂模式解决的问题
每个工厂只能创建一类产品（工厂方法模式），用来生产不同产品族的全部产品。

## 适用场景

抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

![image](https://github.com/aixiaozi/DesignPattern/tree/master/image/car.png)


上图发动机、座椅、轮胎是一个产品族，而这些产品又分为高档、中档、低档，在两个维度变化。

### 优点
- 降低耦合
- 符合开-闭原则
- 符合单一职责原则
- 不使用静态工厂方法，可以形成基于继承的等级结构。

### 缺点
- 难以扩展新种类产品


### 应用场景：
1) JDK中Calendar的getInstance方法；
2) JDBC中Connection对象的获取；
3) Hibernate中SessionFactory创建Session;
4) Spring中IOC容器创建管理bean对象；
5) XML解析时的DocumentBuilderFactory创建解析器对象；
6) 反射中Class对象的newInstance()。


-----------------
# 总结

- 简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（继承自一个父类或接口）的实例。

- 工厂方法：定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象

- 抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。

### 对比

- 工厂方法模式解决了简单工厂模式的“开放 - 关闭原则
- 抽象工厂模式解决了工厂方法模式一个具体工厂只能创建一类产品



- 简单工厂模式(静态工厂模式) -- 虽然某种程度不符合设计原则，但实际使用最多。

- 工厂方法模式 -- 不修改已有类的前提下，通过增加新的工厂类实现扩展。

- 抽象工厂模式 -- 不可以增加产品，可以增加产品族。

- [参考链接](https://blog.csdn.net/cs_lwb/article/details/83999073)
